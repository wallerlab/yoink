//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.7 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.12.29 at 10:54:28 PM EST 
//

package org.xml_cml.schema;

import java.math.BigInteger;
import java.util.HashMap;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyAttribute;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;

import org.w3c.dom.Element;

/**
 * <p>
 * Java class for anonymous complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;choice maxOccurs="unbounded" minOccurs="0">
 *         &lt;element ref="{http://www.xml-cml.org/schema}anyCml"/>
 *         &lt;any processContents='lax' namespace='##other'/>
 *         &lt;any processContents='lax' namespace=''/>
 *       &lt;/choice>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}hydrogenCountArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}dictRef"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}elementTypeArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}yFractArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}countArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}title"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}y2Array"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}formalChargeArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}x2Array"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}y3Array"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}atomIDArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}z3Array"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}zFractArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}id"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}xFractArray"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}ref"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}convention"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}x3Array"/>
 *       &lt;attGroup ref="{http://www.xml-cml.org/schema}occupancyArray"/>
 *       &lt;anyAttribute processContents='lax' namespace='##other'/>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = { "anyCmlOrAnyOrAny" })
public class AtomArray {

	@XmlElementRef(name = "anyCml", namespace = "http://www.xml-cml.org/schema", type = JAXBElement.class, required = false)
	@XmlAnyElement(lax = true)
	protected java.util.List<java.lang.Object> anyCmlOrAnyOrAny;
	@XmlAttribute(name = "hydrogenCount")
	protected java.util.List<BigInteger> hydrogenCount;
	@XmlAttribute(name = "dictRef")
	protected String dictRef;
	@XmlAttribute(name = "elementType")
	protected java.util.List<String> elementType;
	@XmlAttribute(name = "yFract")
	protected java.util.List<Double> yFract;
	@XmlAttribute(name = "count")
	protected java.util.List<Double> count;
	@XmlAttribute(name = "title")
	protected String title;
	@XmlAttribute(name = "y2")
	protected java.util.List<Double> y2;
	@XmlAttribute(name = "formalCharge")
	protected java.util.List<BigInteger> formalCharge;
	@XmlAttribute(name = "x2")
	protected java.util.List<Double> x2;
	@XmlAttribute(name = "y3")
	protected java.util.List<Double> y3;
	@XmlAttribute(name = "atomID")
	protected java.util.List<String> atomID;
	@XmlAttribute(name = "z3")
	protected java.util.List<Double> z3;
	@XmlAttribute(name = "zFract")
	protected java.util.List<Double> zFract;
	@XmlAttribute(name = "id")
	protected String id;
	@XmlAttribute(name = "xFract")
	protected java.util.List<Double> xFract;
	@XmlAttribute(name = "ref")
	protected String ref;
	@XmlAttribute(name = "convention")
	protected String convention;
	@XmlAttribute(name = "x3")
	protected java.util.List<Double> x3;
	@XmlAttribute(name = "occupancy")
	protected java.util.List<Double> occupancy;
	@XmlAnyAttribute
	private java.util.Map<QName, String> otherAttributes = new HashMap<QName, String>();

	/**
	 * Gets the value of the anyCmlOrAnyOrAny property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the anyCmlOrAnyOrAny property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getAnyCmlOrAnyOrAny().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link JAXBElement }{@code <}{@link Line3 }{@code >} {@link JAXBElement }
	 * {@code <}{@link SubstanceList }{@code >} {@link JAXBElement }{@code <}
	 * {@link java.lang.Object }{@code >} {@link JAXBElement }{@code <}
	 * {@link TransitionState }{@code >} {@link JAXBElement }{@code <}
	 * {@link ReactionScheme }{@code >} {@link JAXBElement }{@code <}
	 * {@link MechanismComponent }{@code >} {@link JAXBElement }{@code <}
	 * {@link Yaxis }{@code >} {@link JAXBElement }{@code <}{@link AtomArray }
	 * {@code >} {@link JAXBElement }{@code <}{@link Metadata }{@code >}
	 * {@link JAXBElement }{@code <}{@link Band }{@code >} {@link JAXBElement }
	 * {@code <}{@link ZMatrix }{@code >} {@link JAXBElement }{@code <}
	 * {@link Fragment }{@code >} {@link JAXBElement }{@code <}{@link Reaction }
	 * {@code >} {@link JAXBElement }{@code <}{@link FragmentList }{@code >}
	 * {@link JAXBElement }{@code <}{@link Electron }{@code >} {@link JAXBElement }
	 * {@code <}{@link MoleculeList }{@code >} {@link JAXBElement }{@code <}
	 * {@link Isotope }{@code >} {@link java.lang.Object } {@link JAXBElement }
	 * {@code <}{@link Plane3 }{@code >} {@link JAXBElement }{@code <}
	 * {@link LatticeVector }{@code >} {@link JAXBElement }{@code <}
	 * {@link org.xml_cml.schema.ArrayList }{@code >} {@link JAXBElement }{@code <}
	 * {@link AtomParity }{@code >} {@link Element } {@link JAXBElement }{@code <}
	 * {@link SpectrumData }{@code >} {@link JAXBElement }{@code <}
	 * {@link TableCell }{@code >} {@link JAXBElement }{@code <}{@link Matrix }
	 * {@code >} {@link JAXBElement }{@code <}{@link Gradient }{@code >}
	 * {@link JAXBElement }{@code <}{@link Point3 }{@code >} {@link JAXBElement }
	 * {@code <}{@link org.xml_cml.schema.List }{@code >} {@link JAXBElement }
	 * {@code <}{@link CellParameter }{@code >} {@link JAXBElement }{@code <}
	 * {@link Cml }{@code >} {@link JAXBElement }{@code <}{@link Dimension }
	 * {@code >} {@link JAXBElement }{@code <}{@link PeakGroup }{@code >}
	 * {@link JAXBElement }{@code <}{@link Transform3 }{@code >}
	 * {@link JAXBElement }{@code <}{@link Sample }{@code >} {@link JAXBElement }
	 * {@code <}{@link Scalar }{@code >} {@link JAXBElement }{@code <}
	 * {@link Module }{@code >} {@link JAXBElement }{@code <}{@link Spectator }
	 * {@code >} {@link JAXBElement }{@code <}{@link Unit }{@code >}
	 * {@link JAXBElement }{@code <}{@link Link }{@code >} {@link JAXBElement }
	 * {@code <}{@link Description }{@code >} {@link JAXBElement }{@code <}
	 * {@link BondArray }{@code >} {@link JAXBElement }{@code <}{@link Dictionary }
	 * {@code >} {@link JAXBElement }{@code <}{@link UnitType }{@code >}
	 * {@link JAXBElement }{@code <}{@link Observation }{@code >}
	 * {@link JAXBElement }{@code <}{@link Amount }{@code >} {@link JAXBElement }
	 * {@code <}{@link Join }{@code >} {@link JAXBElement }{@code <}
	 * {@link TableHeader }{@code >} {@link JAXBElement }{@code <}{@link PeakList }
	 * {@code >} {@link JAXBElement }{@code <}{@link PeakStructure }{@code >}
	 * {@link JAXBElement }{@code <}{@link TableRow }{@code >} {@link JAXBElement }
	 * {@code <}{@link Substance }{@code >} {@link JAXBElement }{@code <}
	 * {@link ReactiveCentre }{@code >} {@link JAXBElement }{@code <}{@link Entry }
	 * {@code >} {@link JAXBElement }{@code <}{@link Property }{@code >}
	 * {@link JAXBElement }{@code <}{@link UnitTypeList }{@code >}
	 * {@link JAXBElement }{@code <}{@link BondTypeList }{@code >}
	 * {@link JAXBElement }{@code <}{@link BasisSet }{@code >} {@link JAXBElement }
	 * {@code <}{@link Identifier }{@code >} {@link JAXBElement }{@code <}
	 * {@link BondStereo }{@code >} {@link JAXBElement }{@code <}
	 * {@link KpointList }{@code >} {@link JAXBElement }{@code <}{@link Torsion }
	 * {@code >} {@link JAXBElement }{@code <}{@link Crystal }{@code >}
	 * {@link JAXBElement }{@code <}{@link Atom }{@code >} {@link JAXBElement }
	 * {@code <}{@link Kpoint }{@code >} {@link JAXBElement }{@code <}
	 * {@link Length }{@code >} {@link JAXBElement }{@code <}{@link Particle }
	 * {@code >} {@link JAXBElement }{@code <}{@link Action }{@code >}
	 * {@link JAXBElement }{@code <}{@link Table }{@code >} {@link JAXBElement }
	 * {@code <}{@link Stmml }{@code >} {@link JAXBElement }{@code <}
	 * {@link PropertyList }{@code >} {@link JAXBElement }{@code <}
	 * {@link AtomType }{@code >} {@link JAXBElement }{@code <}{@link UnitList }
	 * {@code >} {@link JAXBElement }{@code <}{@link MetadataList }{@code >}
	 * {@link JAXBElement }{@code <}{@link ReactionStepList }{@code >}
	 * {@link JAXBElement }{@code <}{@link Molecule }{@code >} {@link JAXBElement }
	 * {@code <}{@link IsotopeList }{@code >} {@link JAXBElement }{@code <}
	 * {@link Peak }{@code >} {@link JAXBElement }{@code <}{@link PotentialForm }
	 * {@code >} {@link JAXBElement }{@code <}{@link BandList }{@code >}
	 * {@link JAXBElement }{@code <}{@link TableContent }{@code >}
	 * {@link JAXBElement }{@code <}{@link ProductList }{@code >}
	 * {@link JAXBElement }{@code <}{@link PotentialList }{@code >}
	 * {@link JAXBElement }{@code <}{@link org.xml_cml.schema.Object }{@code >}
	 * {@link JAXBElement }{@code <}{@link ActionList }{@code >}
	 * {@link JAXBElement }{@code <}{@link ReactionList }{@code >}
	 * {@link JAXBElement }{@code <}{@link Spectrum }{@code >} {@link JAXBElement }
	 * {@code <}{@link Eigen }{@code >} {@link JAXBElement }{@code <}
	 * {@link ConditionList }{@code >} {@link JAXBElement }{@code <}
	 * {@link SpectatorList }{@code >} {@link JAXBElement }{@code <}
	 * {@link ParameterList }{@code >} {@link JAXBElement }{@code <}
	 * {@link ReactantList }{@code >} {@link JAXBElement }{@code <}
	 * {@link Reactant }{@code >} {@link JAXBElement }{@code <}{@link BondSet }
	 * {@code >} {@link JAXBElement }{@code <}{@link TableHeaderCell }{@code >}
	 * {@link JAXBElement }{@code <}{@link System }{@code >} {@link JAXBElement }
	 * {@code <}{@link Mechanism }{@code >} {@link JAXBElement }{@code <}
	 * {@link Abundance }{@code >} {@link JAXBElement }{@code <}{@link Bond }
	 * {@code >} {@link JAXBElement }{@code <}{@link Name }{@code >}
	 * {@link JAXBElement }{@code <}{@link Array }{@code >} {@link JAXBElement }
	 * {@code <}{@link Vector3 }{@code >} {@link JAXBElement }{@code <}
	 * {@link AtomicBasisFunction }{@code >} {@link JAXBElement }{@code <}
	 * {@link TableRowList }{@code >} {@link JAXBElement }{@code <}
	 * {@link Parameter }{@code >} {@link JAXBElement }{@code <}{@link Label }
	 * {@code >} {@link JAXBElement }{@code <}{@link AtomTypeList }{@code >}
	 * {@link JAXBElement }{@code <}{@link Product }{@code >} {@link JAXBElement }
	 * {@code <}{@link Sphere3 }{@code >} {@link JAXBElement }{@code <}
	 * {@link ReactionStep }{@code >} {@link JAXBElement }{@code <}{@link Xaxis }
	 * {@code >} {@link JAXBElement }{@code <}{@link Definition }{@code >}
	 * {@link JAXBElement }{@code <}{@link AtomSet }{@code >} {@link JAXBElement }
	 * {@code <}{@link Formula }{@code >} {@link JAXBElement }{@code <}
	 * {@link Angle }{@code >} {@link JAXBElement }{@code <}{@link Lattice }
	 * {@code >} {@link JAXBElement }{@code <}{@link org.xml_cml.schema.Map }
	 * {@code >} {@link JAXBElement }{@code <}{@link Potential }{@code >}
	 * {@link JAXBElement }{@code <}{@link Documentation }{@code >}
	 * {@link JAXBElement }{@code <}{@link Symmetry }{@code >} {@link JAXBElement }
	 * {@code <}{@link SpectrumList }{@code >} {@link JAXBElement }{@code <}
	 * {@link Region }{@code >} {@link JAXBElement }{@code <}{@link BondType }
	 * {@code >}
	 * 
	 * 
	 */
	public java.util.List<java.lang.Object> getAnyCmlOrAnyOrAny() {
		if (anyCmlOrAnyOrAny == null) {
			anyCmlOrAnyOrAny = new java.util.ArrayList<java.lang.Object>();
		}
		return this.anyCmlOrAnyOrAny;
	}

	/**
	 * Gets the value of the hydrogenCount property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the hydrogenCount property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getHydrogenCount().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link BigInteger }
	 * 
	 * 
	 */
	public java.util.List<BigInteger> getHydrogenCount() {
		if (hydrogenCount == null) {
			hydrogenCount = new java.util.ArrayList<BigInteger>();
		}
		return this.hydrogenCount;
	}

	/**
	 * Gets the value of the dictRef property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getDictRef() {
		return dictRef;
	}

	/**
	 * Sets the value of the dictRef property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setDictRef(String value) {
		this.dictRef = value;
	}

	/**
	 * Gets the value of the elementType property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the elementType property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getElementType().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link String }
	 * 
	 * 
	 */
	public java.util.List<String> getElementType() {
		if (elementType == null) {
			elementType = new java.util.ArrayList<String>();
		}
		return this.elementType;
	}

	/**
	 * Gets the value of the yFract property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the yFract property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getYFract().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getYFract() {
		if (yFract == null) {
			yFract = new java.util.ArrayList<Double>();
		}
		return this.yFract;
	}

	/**
	 * Gets the value of the count property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the count property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getCount().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getCount() {
		if (count == null) {
			count = new java.util.ArrayList<Double>();
		}
		return this.count;
	}

	/**
	 * Gets the value of the title property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getTitle() {
		return title;
	}

	/**
	 * Sets the value of the title property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setTitle(String value) {
		this.title = value;
	}

	/**
	 * Gets the value of the y2 property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the y2 property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getY2().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getY2() {
		if (y2 == null) {
			y2 = new java.util.ArrayList<Double>();
		}
		return this.y2;
	}

	/**
	 * Gets the value of the formalCharge property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the formalCharge property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getFormalCharge().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link BigInteger }
	 * 
	 * 
	 */
	public java.util.List<BigInteger> getFormalCharge() {
		if (formalCharge == null) {
			formalCharge = new java.util.ArrayList<BigInteger>();
		}
		return this.formalCharge;
	}

	/**
	 * Gets the value of the x2 property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the x2 property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getX2().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getX2() {
		if (x2 == null) {
			x2 = new java.util.ArrayList<Double>();
		}
		return this.x2;
	}

	/**
	 * Gets the value of the y3 property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the y3 property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getY3().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getY3() {
		if (y3 == null) {
			y3 = new java.util.ArrayList<Double>();
		}
		return this.y3;
	}

	/**
	 * Gets the value of the atomID property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the atomID property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getAtomID().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link String }
	 * 
	 * 
	 */
	public java.util.List<String> getAtomID() {
		if (atomID == null) {
			atomID = new java.util.ArrayList<String>();
		}
		return this.atomID;
	}

	/**
	 * Gets the value of the z3 property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the z3 property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getZ3().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getZ3() {
		if (z3 == null) {
			z3 = new java.util.ArrayList<Double>();
		}
		return this.z3;
	}

	/**
	 * Gets the value of the zFract property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the zFract property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getZFract().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getZFract() {
		if (zFract == null) {
			zFract = new java.util.ArrayList<Double>();
		}
		return this.zFract;
	}

	/**
	 * Gets the value of the id property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getId() {
		return id;
	}

	/**
	 * Sets the value of the id property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setId(String value) {
		this.id = value;
	}

	/**
	 * Gets the value of the xFract property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the xFract property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getXFract().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getXFract() {
		if (xFract == null) {
			xFract = new java.util.ArrayList<Double>();
		}
		return this.xFract;
	}

	/**
	 * Gets the value of the ref property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getRef() {
		return ref;
	}

	/**
	 * Sets the value of the ref property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setRef(String value) {
		this.ref = value;
	}

	/**
	 * Gets the value of the convention property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getConvention() {
		return convention;
	}

	/**
	 * Sets the value of the convention property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setConvention(String value) {
		this.convention = value;
	}

	/**
	 * Gets the value of the x3 property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the x3 property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getX3().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getX3() {
		if (x3 == null) {
			x3 = new java.util.ArrayList<Double>();
		}
		return this.x3;
	}

	/**
	 * Gets the value of the occupancy property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the occupancy property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getOccupancy().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Double }
	 * 
	 * 
	 */
	public java.util.List<Double> getOccupancy() {
		if (occupancy == null) {
			occupancy = new java.util.ArrayList<Double>();
		}
		return this.occupancy;
	}

	/**
	 * Gets a map that contains attributes that aren't bound to any typed
	 * property on this class.
	 * 
	 * <p>
	 * the map is keyed by the name of the attribute and the value is the string
	 * value of the attribute.
	 * 
	 * the map returned by this method is live, and you can add new attribute by
	 * updating the map directly. Because of this design, there's no setter.
	 * 
	 * 
	 * @return always non-null
	 */
	public java.util.Map<QName, String> getOtherAttributes() {
		return otherAttributes;
	}

}
